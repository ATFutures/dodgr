---
title: "dodgr"
author: "Mark Padgham"
date: "`r Sys.Date()`"
output: 
    html_document:
        toc: true
        toc_float: true
        number_sections: true
        theme: flatly
header-includes: 
    - \usepackage{tikz}
    - \usetikzlibrary{arrows}
vignette: >
  %\VignetteIndexEntry{dodgr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE}
devtools::load_all (".")
```

# Background

`dodgr` is an R package for calculating **D**istances **O**n **D**irected
**G**raphs. Skip straight to the Intro if you know what those are (but maybe
make a brief stop-in to Dual-weighted directed graphs below.) Directed graphs
are ones in which the "distance" (or some equivalent measure) from A to B is not
necessarily equal to that from B to A. In Fig. 1, for example, the weights
between the graph vertices (A, B, C, and D) differ depending on the direction of
travel, and it is only possible to traverse the entire graph in an
anti-clockwise direction.

```{r, fig.align="center", echo=FALSE, engine='tikz',fig.ext='svg', code=readLines("fig1.tex"), fig.cap="Figure 1: A weighted, directed graph"}
```

Graphs in `dodgr` are represented by simple flat `data.frame` objects, so the
graph of Fig. 1, presuming the edge weights to take values of 1, 2, and 3, would
be,
```{r, echo = FALSE}
graph <- data.frame (from = c ("A", "B", "B", "B", "C", "C", "D", "D"),
                     to = c ("B", "A", "C", "D", "B", "D", "C", "A"),
                     d = c (1, 2, 1, 3, 2, 1, 2, 1))
graph
```
The primary function of `dodgr` is `dodgr_dists`, which calculates pair-wise
shortest distances between all vertices of a graph.
```{r}
dodgr_dists (graph)
```


## Dual-weighted directed graphs

Shortest-path distances on weighted graphs can be calculated using a number of
other **R** packages, such as
[`igraph`](https://cran.r-project.org/package=igraph) or
[`e1071`](https://cran.r-project.org/package=e1071). `dodgr` comes into its own
through its ability to trace paths through *dual-weighted* directed graphs,
illustrated in Fig. 2.

```{r, fig.align="center", echo=FALSE, engine='tikz',fig.ext='svg', code=readLines("fig2.tex"), fig.cap="Figure 2: A **dual**-weighted, directed graph in which the weights (represented by thicknesses) of the grey arrows differ from those of the black arrows."}
```
These are common in many areas, with a foremost example arising in routing
through street networks. The route one takes through a street network depends on
the mode of transport: the route a pedestrian might taken will generally differ
markedly from the route the same person might take if behind the wheel of an
automobile. Routing through street networks thus generally requires each edge to
be specified with two weights or distances: one quantifying the physical
distance, and a second weighted version reflecting the mode of transport (or
some other preferential weighting).

`dodgr` calculates shortest paths using one set of weights (called "weights" or
anything else starting with "w"), but returns the actual lengths of them using a
second set of weights (called "distances", or anything else starting with "d").
If no weights are specified, distances alone are used both for routing and final
distance calculations.  Consider that the weights and distances of Fig. 2 are
the black and grey lines, respectively, with the latter all equal to one. In
this case, the graph and associated shortest distances are,
```{r, echo = FALSE}
graph <- data.frame (from = c ("A", "B", "B", "B", "C", "C", "D", "D"),
                     to = c ("B", "A", "C", "D", "B", "D", "C", "A"),
                     w = c (1, 2, 1, 3, 2, 1, 2, 1),
                     d = c (1, 1, 1, 1, 1, 1, 1, 1))
graph
dodgr_dists (graph)
```
Note that even though the shortest "distance" from A to D is actually
A$\to$B$\to$D with a distance of only 2, that path has a weighted distance of
1 + 3 = 4. The shortest *weighted* path is A$\to$B$\to$C$\to$D, with a distance
both weighted and unweighted of 1 + 1 + 1 = 3. Thus `d(A,D) = 3` and not 2.

# Introduction to the package

Although the package was intentionally developed to be adaptable to any kinds of
networks, the primary motivation was routing through street networks.
Accordingly, most of the applications illustrated here concern street networks,
and also illustrate several helper functions the package offers for working with
street networks. The basic `graph` object of `dodgr` is nevertheless arbitrary,
and need only minimally contain three or four columns as demonstrated in the
simple examples at the outset.

The package may be used to calculate a matrix of distances between a given set
of geographic coordinates. We can start by simply generating some random
coordinates, in this case within the bounding box defining the city of York in
the U.K.
```{r get-york-data}
bb <- osmdata::getbb ("york uk")
npts <- 1000
xy <- apply (bb, 1, function (i) min (i) + runif (npts) * diff (i))
bb; head (xy)
```
Those points can simply be passed to `dodgr_dists()`:
```{r dodgr-dists-in-york, eval = FALSE}
system.time(
            d <- dodgr_dists (from = xy, wt_profile = "foot", quiet = FALSE)
            )
```
```{r, echo = FALSE}
message (paste0 ("No graph submitted to dodgr_dists; ",
                 "downloading street network ... done\n",
                 "Converting network to dodgr graph ... done\n",
                 "Calculating shortest paths ... done"))
```
```{r, echo = FALSE}
st <- system.time (Sys.sleep (0.1))
st [1] <- 26.620
st [2] <- 0.132
st [3] <- 28.567
st
```
```{r, eval = FALSE}
dim (d); range (d, na.rm = TRUE)
```
```{r, echo = FALSE}
c (1000, 1000)
c (0.00000, 46.60609)
```
The result is a matrix of 1000-by-1000 distances of up to 47km long, measured
along routes weighted for optimal pedestrian travel. In this case, the single
call to `dodgr_dists()` automatically downloaded the entire street network of York
and calculated one million shortest-path distances, all in under 30 seconds.

# Street networks and graphs

Although the above code is short and fast, most users will probably want more
control over their graphs and routing possibilities. Each of the steps indicated
above (through the `quiet = FALSE` option) can be implemented separately. To
begin, let's download a street network:
```{r, york-streetnet, eval = FALSE}
streetnet <- dodgr_streetnet ("york uk")
class (streetnet)
```
```{r, echo = FALSE}
c ("sf", "data.frame")
```
```{r, eval = FALSE}
class (streetnet$geometry)
```
```{r, echo = FALSE}
c ("sfc_LINESTRING", "sfc")
```
```{r, eval = FALSE}
dim (streetnet)
```
```{r, echo = FALSE}
c (18284, 181)
```
The `streetnet` is an [`sf`](https://cran.r-project.org/package=sf) (Simple
Features) object containing 18,284 `LINESTRING` geometries. In other words, it's
got an `sf` representation of 18,284 streets.

That `sf` representation can then be converted into a flat `data.frame` object
by
```{r, eval = FALSE}
graph <- weight_streetnet (streetnet, wt_profile = "bicycle")
class (graph)
```
```{r, echo = FALSE}
"data.frame"
```
```{r, eval = FALSE}
dim (graph)
```
```{r, echo = FALSE}
c (187300, 10)
```
```{r, eval = FALSE}
head (graph)
```
```{r, echo = FALSE}
from_id <- c (13060397, 13060402, 13060402, 13060405, 13060405, 13060413)
from_id <- as.character (from_id)
from_lon <- c ( -1.001714, -1.001607, -1.001607, -1.001372, -1.001372, -1.001113)
from_lat <- c ( 53.95737, 53.95746, 53.95746, 53.95763, 53.95763, 53.95776)
to_id <- c (13060402, 13060397, 13060405, 13060402, 13060413, 13060405)
to_id <- as.character (to_id)
to_lon <- c (-1.001607, -1.001714, -1.001372, -1.001607, -1.001113, -1.001372)
to_lat <- c (53.95746, 53.95737, 53.95763, 53.95746, 53.95776, 53.95763)
d <- c (0.006909587, 0.006909587, 0.013732955, 0.013732955, 0.013148026,
        0.013148026)
d_weighted <- c (0.007677319, 0.007677319, 0.015258839, 0.015258839,
                 0.014608918, 0.014608918)
highway <- rep ("unclassified", length (from_id))
data.frame (from_id = as.character (from_id),
                     from_lon = from_lon, from_lat = from_lat,
                     to_id = as.character (to_id),
                     to_lon = to_lon, to_lat = to_lat,
                     d = d, d_weighted = d_weighted, highway = highway,
                     stringsAsFactors = FALSE)
```
And the actual graph contains around 10 times as many edges as there are
streets. That indicates that each street contains on average around 11 vertices
or nodes, between which there are 10 edges. This `data.frame` graph structure is
what `dodgr` uses to calculate shortest path routes. Note that the
weighted---here referred to as `d_weighted`---are all considerably greater than
the actual distances. There are many different `highway` types:
```{r, eval = FALSE}
table (graph$highway)
```
```{r, echo = FALSE}
tb <- c (3122, 222, 11079, 35518, 106, 5856, 381, 2815, 23, 60, 41369, 308,
         4016, 8, 32077, 734, 15006, 26, 16452, 3144, 371, 14607)
names (tb) <- c ("bridleway", "construction", "cycleway", "footway",
                 "living_street", "path", "pedestrian", "primary",
                 "primary_link", "raceway", "residential", "road", "secondary",
                 "secondary_link", "service", "steps", "tertiary",
                 "tertiary_link", "track", "trunk", "trunk_link",
                 "unclassified")
tb
```
Each of these types has its own weight defined by the named weighting profile.
These are included with the `dodgr` package:
```{r}
names (weighting_profiles)
class (weighting_profiles)
weighting_profiles [weighting_profiles$name == "foot", ]
```
