% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flows.R
\name{dodgr_flows_si}
\alias{dodgr_flows_si}
\title{dodgr_flows_si}
\usage{
dodgr_flows_si(graph, from, to, k = 500, dens_from = NULL,
  dens_to = NULL, contract = FALSE, heap = "BHeap",
  tol = 0.000000000001, quiet = TRUE)
}
\arguments{
\item{graph}{\code{data.frame} or equivalent object representing the network
graph (see Details)}

\item{from}{Vector or matrix of points \strong{from} which aggregate flows are to
be calculated (see Details)}

\item{to}{Vector or matrix of points \strong{to} which aggregate flows are to be
calculated (see Details)}

\item{k}{Either single value specifying width of exponential spatial
interaction function (exp (-d / k)), or vector of independent values for each
origin point (with same length as 'from' points).}

\item{dens_from}{Vector of densities at origin ('from') points}

\item{dens_to}{Vector of densities at destination ('to') points}

\item{contract}{If \code{TRUE}, calculate flows on contracted graph before
mapping them back on to the original full graph (recommended as this will
generally be much faster).}

\item{heap}{Type of heap to use in priority queue. Options include
Fibonacci Heap (default; \code{FHeap}), Binary Heap (\code{BHeap}),
\code{Radix}, Trinomial Heap (\code{TriHeap}), Extended Trinomial Heap
(\code{TriHeapExt}, and 2-3 Heap (\code{Heap23}).}

\item{tol}{Relative tolerance below which flows towards \code{to} vertices are not
considered. This will generally have no effect, but can provide speed gains
when flow matrices represent spatial interaction models, in which case this
parameter effectively reduces the radius from each \code{from} point over which
flows are aggregated. To remove any such effect, set \code{tol = 0}.}

\item{quiet}{If \code{FALSE}, display progress messages on screen.}
}
\value{
Modified version of graph with additonal \code{flow} column added.
}
\description{
Aggregate flows throughout a network based using an exponential Spatial
Interaction (SI) model between a specified set of origin and destination
points, and associated vectors of densities.
}
\examples{
graph <- weight_streetnet (hampi)
from <- sample (graph$from_id, size = 10)
to <- sample (graph$to_id, size = 5)
to <- to [!to \%in\% from]
flows <- matrix (10 * runif (length (from) * length (to)),
                 nrow = length (from))
graph <- dodgr_flows_aggregate (graph, from = from, to = to, flows = flows)
# graph then has an additonal 'flows' column of aggregate flows along all
# edges. These flows are directed, and can be aggregated to equivalent
# undirected flows on an equivalent undirected graph with:
graph_undir <- merge_directed_graph (graph)
# This graph will only include those edges having non-zero flows, and so:
nrow (graph); nrow (graph_undir) # the latter is much smaller
}
