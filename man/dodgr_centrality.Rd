% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/centrality.R
\name{dodgr_centrality}
\alias{dodgr_centrality}
\title{dodgr_centrality}
\usage{
dodgr_centrality(graph, contract = TRUE, edges = TRUE,
  heap = "BHeap", parallel = FALSE)
}
\arguments{
\item{graph}{\code{data.frame} or equivalent object representing the network
graph (see Details)}

\item{contract}{If \code{TRUE}, centrality is calculated on contracted graph
before mapping back on to the original full graph. Note that for street
networks, in particular those obtained from the \pkg{osmdata} package, vertex
placement is effectively arbitrary except at junctions; centrality for such
graphs should only be calculated between the latter points, and thus
\code{contract} should always be \code{TRUE}.}

\item{edges}{If \code{TRUE}, centrality is calculated for graph edges, returning
the input \code{graph} with an additional \code{centrality} column; otherwise
centrality is calculated for vertices, returning the equivalent of
\code{dodgr_vertices(graph)}, with an additional vertex-based \code{centrality} column.}

\item{heap}{Type of heap to use in priority queue. Options include
Fibonacci Heap (default; \code{FHeap}), Binary Heap (\code{BHeap}),
\code{Radix}, Trinomial Heap (\code{TriHeap}), Extended Trinomial Heap
(\code{TriHeapExt}, and 2-3 Heap (\code{Heap23}).}

\item{parallel}{Calculate in parallel?}
}
\value{
Modified version of graph with additonal \code{centrality} column added.
}
\description{
Calculate betweenness centrality for a \code{dodgr} network, in either vertex- or
edge-based form.
}
\examples{
graph_full <- weight_streetnet (hampi)
graph <- dodgr_contract_graph (graph_full)
graph <- dodgr_centrality (graph)
# 'graph' is then the contracted graph with an additional 'centrality' column
# Values of centrality between all junctions in the contracted graph can then
# be mapped back onto the original full network by "uncontracting":
graph_full <- dodgr_uncontract_graph (graph)
# For visualisation, it is generally necessary to merge the directed edges to
# form an equivalent undirected graph. Conversion to 'sf' format via
# 'dodgr_to_sf()' is also useful for many visualisation routines.
graph_sf <- merge_directed_graph (graph_full) \%>\%
    dodgr_to_sf ()

\dontrun{
library (mapview)
centrality <- graph_sf$centrality / max (graph_sf$centrality)
ncols <- 30
cols <- colorRampPalette (c ("lawngreen", "red")) (ncols) [ceiling (ncols * centrality)]
mapview (graph_sf, color = cols, lwd = 10 * centrality)
}

# An example of flow aggregation across a generic (non-OSM) highway,
# represented as the `routes_fast` object of the \\pkg{stplanr} package,
# which is a SpatialLinesDataFrame containing commuter densities along
# components of a street network.
\dontrun{
library (stplanr)
# merge all of the 'routes_fast' lines into a single network
r <- overline (routes_fast, attrib = "length", buff_dist = 1)
r <- sf::st_as_sf (r)
# Convert to a 'dodgr' network, for which we need to specify both a `type` and
# `id` column.
r$type <- 1
r$id <- seq (nrow (r))
graph_full <- weight_streetnet (r, type_col = "type", id_col = "id",
                                wt_profile = 1)
# convert to contracted form, retaining junction vertices only, and append
# 'centrality' column
graph <- dodgr_contract_graph (graph_full) \%>\%
    dodgr_centrality ()
#' expand back to full graph; merge directed flows; and convert result to
# 'sf'-format for plotting
graph_sf <- dodgr_uncontract_graph (graph) \%>\%
    merge_directed_graph () \%>\%
    dodgr_to_sf ()
plot (graph_sf ["centrality"])
}

}
