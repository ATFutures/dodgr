#' dodgr_isodists
#'
#' Calculate isodistance contours from specified points. Function is fully
#' vectorized to calculate accept vectors of central points and vectors
#' defining multiple isodistances.
#'
#' @param graph `data.frame` or equivalent object representing the network
#' graph (see Notes)
#' @param from Vector or matrix of points **from** which isodistances are to
#' be calculated.
#' @param dlim Vector of desired limits of isodistances in metres.
#' @param heap Type of heap to use in priority queue. Options include
#' Fibonacci Heap (default; `FHeap`), Binary Heap (`BHeap`),
#' `Radix`, Trinomial Heap (`TriHeap`), Extended Trinomial Heap
#' (`TriHeapExt`, and 2-3 Heap (`Heap23`).
#' @return A single `data.frame` of isodistances as points sorted anticlockwise
#' around each origin (`from`) point, with columns denoting the `from` points
#' and `dlim` value(s). The isodistance contours are given as `id` values and
#' associated coordinates of the series of points from each `from` point at the
#' specified isodistances.
#'
#' @export 
#' @examples
#' graph <- weight_streetnet (hampi)
#' from <- sample (graph$from_id, size = 100)
#' dlim <- c (1, 2, 5, 10, 20) * 100
#' d <- dodgr_isodists (graph, from = from, dlim)
dodgr_isodists <- function (graph, from = NULL, dlim = NULL, heap = 'BHeap')
{
    if (is.null (dlim))
        stop ("dlim must be specified")
    if (!is.numeric (dlim))
        stop ("dlim must be numeric")

    dat <- iso_pre (graph, from, heap)

    d <- rcpp_get_iso (dat$graph, dat$vert_map, dat$from_index$index,
                       dlim, dat$heap)
    # verts inside the isohull are flagged with -1, and are removed here:
    d [d < 0] <- NA

    if (!is.null (dat$from_index$id))
        rownames (d) <- dat$from_index$id
    else
        rownames (d) <- dat$vert_map$vert
    colnames (d) <- dat$vert_map$vert

    return (dmat_to_pts (d, dat$from_index$id, dat$v, dlim))
}

iso_pre <- function (graph, from = NULL, heap = "BHeap")
{
    v <- dodgr_vertices (graph)
    graph <- tbl_to_df (graph)

    hps <- get_heap (heap, graph)
    heap <- hps$heap
    graph <- hps$graph

    gr_cols <- dodgr_graph_cols (graph)
    if (is.na (gr_cols$from) | is.na (gr_cols$to))
    {
        scols <- find_spatial_cols (graph)
        graph$from_id <- scols$xy_id$xy_fr_id
        graph$to_id <- scols$xy_id$xy_to_id
        gr_cols <- dodgr_graph_cols (graph)
    }
    vert_map <- make_vert_map (graph, gr_cols, FALSE)

    tp <- attr (graph, "turn_penalty")
    tp <- ifelse (is.null (tp), 0, tp)
    if (is (graph, "dodgr_streetnet_sc") & tp > 0)
    {
        if (!is.null (from))
        {
            from <- nodes_arg_to_pts (from, graph)
            from <- remap_verts_with_turn_penalty (graph, from, from = TRUE)
        }
    }

    from_index <- get_to_from_index (graph, vert_map, gr_cols, from)

    graph <- convert_graph (graph, gr_cols)

    list (v = v,
          graph = graph,
          vert_map = vert_map,
          from_index = from_index,
          heap = heap)
}

#' dodgr_isochrones
#'
#' Calculate isochrone contours from specified points. Function is fully
#' vectorized to calculate accept vectors of central points and vectors 
#' defining multiple isochrone thresholds.
#'
#' @inherit dodgr_isodists
#'
#' @param from Vector or matrix of points **from** which isochrones are to
#' be calculated.
#' @param tlim Vector of desired limits of isochrones in seconds
#' @return A single `data.frame` of isochrones as points sorted anticlockwise
#' around each origin (`from`) point, with columns denoting the `from` points
#' and `tlim` value(s). The isochrones are given as `id` values and associated
#' coordinates of the series of points from each `from` point at the specified
#' isochrone times.
#'
#' @export 
#' @examples
#' \dontrun{
#' # Use osmdata package to extract 'SC'-format data:
#' library (osmdata)
#' dat <- opq ("hampi india") %>%
#'     add_osm_feature (key = "highway") %>%
#'     osmdata_sc ()
#' graph <- weight_streetnet (dat)
#' from <- sample (graph$from_id, size = 100)
#' tlim <- c (5, 10, 20, 30, 60) * 60 # times in seconds
#' x <- dodgr_isochrones (graph, from = from, tlim)
#' }
dodgr_isochrones <- function (graph, from = NULL, tlim = NULL, heap = 'BHeap')
{
    if (!methods::is (graph, "dodgr_streetnet_sc"))
        stop ("isochrones can only be calculated from SC-class networks ",
              "generated by osmdata_sc.")
    graph$d_weighted <- graph$time_weighted
    graph$d <- graph$time

    res <- dodgr_isodists (graph, from = from, dlim = tlim, heap = heap)
    names (res) [names (res) == "dlim"] <- "tlim"
    return (res)
}

# convert distance matrix with values equal to various isodistances into list of
# lists of points ordered around the central points
dmat_to_pts <- function (d, from, v, dlim)
{
    pt_names <- colnames (d)
    pts <- list ()
    for (i in seq (nrow (d)))
    {
        o <- v [match (from [i], v$id), ]
        pts [[i]] <- lapply (dlim, function (j) {
                                 res <- pt_names [which (d [i, ] == j)]
                                 res <- v [match (res, v$id), ]
                                 if (nrow (res) > 0)
                                 {
                                     res$from <- o$id
                                     res <- order_points (res, o)
                                     res$dlim <- j
                                     res <- res [, c ("from", "dlim",
                                                      "id", "x", "y")]
                                 }
                                 return (res)
            })
        names (pts [[i]]) <- paste (dlim)
    }
    names (pts) <- rownames (d)

    # flatten lists
    pts <- do.call (rbind, lapply (pts, function (i) do.call (rbind, i)))
    rownames (pts) <- NULL

    return (pts)
}

# order points around circle
order_points <- function (pts, origin)
{
    dx <- pts$x - origin$x
    dy <- pts$y - origin$y
    theta <- rep (NA, nrow (pts))

    index <- which (dx > 0 & dy >= 0)
    theta [index] <- atan (dy [index] / dx [index])
    index <- which (dx > 0 & dy < 0)
    theta [index] <- 2 * pi + atan (dy [index] / dx [index])
    index <- which (dx < 0)
    theta [index] <- pi + atan (dy [index] / dx [index])
    index <- which (dx == 0 & dy >= 0)
    theta [index] <- 0
    index <- which (dx == 0 & dy < 0)
    theta [index] <- 3 * pi / 2

    pts <- pts [order (theta), c ("from", "id", "x", "y")]
    rbind (pts, pts [1, ])
}
